package lib

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"github.com/kataras/iris/v12/middleware/jwt"
	"google.golang.org/protobuf/types/known/timestamppb"
	"hash"
	"io"
	"strings"
	"time"

	"dapp/schema/dto"
)

// MkAccessToken create a signed JTW token with the specified data. This could be used for authentication purpose by a middleware
func MkAccessToken(data *dto.AccessTokenData, sigKey []byte, tkAge uint8) ([]byte, error) { // https://github.com/kataras/iris/blob/master/_examples/auth/jwt/middleware/main.go | https://github.com/iris-contrib/examples/blob/master/auth/jwt/basic/main.go
	tk, err := jwt.Sign(jwt.HS256, sigKey, data, jwt.MaxAge(time.Duration(tkAge)*time.Minute))
	if err != nil {
		return nil, err
	}

	return tk, err
}

func ComputeDID(data string) (string, error) {
	// Hash it
	_hash := sha256.Sum256([]byte(data))
	base64Hash := base64.StdEncoding.EncodeToString(_hash[:])
	return base64Hash, nil
}

const SHA256 = "SHA256"

// Checksum returns the checksum of some data, using a specified algorithm.
// It only returns an error when an invalid algorithm is used. The valid ones
// are SHA256
func Checksum(algorithm string, data []byte) (checksum string, err error) {
	// default
	var _hash hash.Hash
	switch strings.ToUpper(algorithm) {
	case "SHA256":
		_hash = sha256.New()
	default:
		msg := "invalid algorithm parameter passed go Checksum: %s"
		return checksum, fmt.Errorf(msg, algorithm)
	}
	_hash.Write(data)
	str := hex.EncodeToString(_hash.Sum(nil))
	return str, nil
}

// GenerateUUIDBytes returns a UUID based on RFC 4122 returning the generated bytes
func GenerateUUIDBytes() []byte {
	uuid := make([]byte, 16)
	_, err := io.ReadFull(rand.Reader, uuid)
	if err != nil {
		panic(fmt.Sprintf("Error generating UUID: %s", err))
	}

	// variant bits; see section 4.1.1
	uuid[8] = uuid[8]&^0xc0 | 0x80

	// version 4 (pseudo-random); see section 4.1.3
	uuid[6] = uuid[6]&^0xf0 | 0x40

	return uuid
}

// GenerateUUIDStr returns a UUID based on RFC 4122
func GenerateUUIDStr() string {
	uuid := GenerateUUIDBytes()
	return idBytesToStr(uuid)
}

func GenerateUUIDFormatDate() string {
	bUUID := GenerateUUIDBytes()
	uuid := idBytesToStr(bUUID)

	currentTime := timestamppb.Now()
	strNow := currentTime.AsTime().Format("20060102-150405")
	date := strings.Split(strNow, "-")
	if len(date) != 2 {
		return uuid
	}
	return fmt.Sprintf("%s-%x-%x-%x", strNow, bUUID[6:8], bUUID[8:10], bUUID[10:])
}

func idBytesToStr(id []byte) string {
	return fmt.Sprintf("%x-%x-%x-%x-%x", id[0:4], id[4:6], id[6:8], id[8:10], id[10:])
}
